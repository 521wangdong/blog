(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{373:function(t,a,s){"use strict";s.r(a);var e=s(45),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"react"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("React 是一个用于构建用户界面的 JavaScript 库")])]),t._v(" "),s("h2",{attrs:{id:"函数组件与-class-组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数组件与-class-组件"}},[t._v("#")]),t._v(" 函数组件与 class 组件")]),t._v(" "),s("h3",{attrs:{id:"定义组件最简单的方式就是编写-javascript-函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定义组件最简单的方式就是编写-javascript-函数"}},[t._v("#")]),t._v(" 定义组件最简单的方式就是编写 JavaScript 函数")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Welcome")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("h1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("Hello"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("props"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("h1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数")]),t._v(" "),s("h3",{attrs:{id:"使用-es6-的-class-来定义组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用-es6-的-class-来定义组件"}},[t._v("#")]),t._v(" 使用 ES6 的 class 来定义组件")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Welcome")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("h1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("Hello"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("props"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("h1"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),s("p",[t._v("组件名称必须以大写字母开头\nReact 会将以小写字母开头的组件视为原生 DOM 标签。")])]),t._v(" "),s("h3",{attrs:{id:"将函数组件转换成-class-组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#将函数组件转换成-class-组件"}},[t._v("#")]),t._v(" 将函数组件转换成 class 组件")]),t._v(" "),s("p",[t._v("创建一个同名的 ES6 class，并且继承于 React.Component。\n添加一个空的 render() 方法。\n将函数体移动到 render() 方法之中。\n在 render() 方法中使用 this.props 替换 props。\n删除剩余的空函数声明。")]),t._v(" "),s("h2",{attrs:{id:"props"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#props"}},[t._v("#")]),t._v(" Props")]),t._v(" "),s("p",[t._v("所有 React 组件都必须像纯函数一样保护它们的 props 不被更改\n组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props。\n一般在组件之间传值用")]),t._v(" "),s("h2",{attrs:{id:"state"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#state"}},[t._v("#")]),t._v(" State")]),t._v(" "),s("p",[t._v("组件本身拥有的状态\n不要直接修改 State(而是应该使用 setState()😃\n构造函数是唯一可以给 this.state 赋值的地方")]),t._v(" "),s("h2",{attrs:{id:"区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[t._v("#")]),t._v(" 区别")]),t._v(" "),s("p",[t._v("props（“properties” 的缩写）和 state 都是普通的 JavaScript 对象。它们都是用来保存信息的，这些信息可以控制组件的渲染输出，而它们的一个重要的不同点就是：props 是传递给组件的（类似于函数的形参），而 state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。")]),t._v(" "),s("h3",{attrs:{id:"state-的更新可能是异步的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#state-的更新可能是异步的"}},[t._v("#")]),t._v(" State 的更新可能是异步的")]),t._v(" "),s("p",[t._v("出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。")]),t._v(" "),s("p",[t._v("因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。")]),t._v(" "),s("p",[t._v("要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：")]),t._v(" "),s("h3",{attrs:{id:"setstate到底是异步还是同步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#setstate到底是异步还是同步"}},[t._v("#")]),t._v(" setState到底是异步还是同步")]),t._v(" "),s("p",[t._v("setState只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的")]),t._v(" "),s("p",[t._v("setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前,导致在合成事件和钩子函数中没法立⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果")]),t._v(" "),s("p",[t._v("setState 的批量更新优化也是建立在“异步”(合成事件、钩子函数)之上的，在原生事件和setTimeout 中不会 批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一 次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。")]),t._v(" "),s("h2",{attrs:{id:"setstate栗子"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#setstate栗子"}},[t._v("#")]),t._v(" setState栗子")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" formValues"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" values "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("在callback中可以拿到更新后的值")]),t._v(" "),s("h2",{attrs:{id:"列表-key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#列表-key"}},[t._v("#")]),t._v(" 列表 & Key")]),t._v(" "),s("p",[t._v("key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识")]),t._v(" "),s("p",[t._v("一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key")]),t._v(" "),s("p",[t._v("当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key")]),t._v(" "),s("p",[t._v("如果列表项目的顺序可能会变化，不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题")]),t._v(" "),s("p",[t._v("key 只是在兄弟节点之间必须唯一")]),t._v(" "),s("h2",{attrs:{id:"受控组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#受控组件"}},[t._v("#")]),t._v(" 受控组件")]),t._v(" "),s("p",[t._v("在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同，这是因为表单元素通常会保持一些内部的 state")]),t._v(" "),s("p",[t._v("表单具有默认的 HTML 表单行为，即在用户提交表单后浏览到新页面。如果你在 React 中执行相同的代码，它依然有效。但大多数情况下，使用 JavaScript 函数可以很方便的处理表单的提交， 同时还可以访问用户填写的表单数据。实现这种效果的标准方式是使用“受控组件”。")]),t._v(" "),s("p",[t._v("表单元素（如input、 textarea 和 select）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。")])])}),[],!1,null,null,null);a.default=r.exports}}]);