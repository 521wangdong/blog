<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React | 前端</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="王冬的个人博客">
    
    <link rel="preload" href="/blog/assets/css/0.styles.0b1ac558.css" as="style"><link rel="preload" href="/blog/assets/js/app.b199bffd.js" as="script"><link rel="preload" href="/blog/assets/js/2.5239c051.js" as="script"><link rel="preload" href="/blog/assets/js/14.a6e55d05.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.8711566b.js"><link rel="prefetch" href="/blog/assets/js/11.47db2a95.js"><link rel="prefetch" href="/blog/assets/js/12.97fcf21f.js"><link rel="prefetch" href="/blog/assets/js/13.185b2dd5.js"><link rel="prefetch" href="/blog/assets/js/15.7ade0bad.js"><link rel="prefetch" href="/blog/assets/js/16.ef875214.js"><link rel="prefetch" href="/blog/assets/js/17.2a263d49.js"><link rel="prefetch" href="/blog/assets/js/18.55103cda.js"><link rel="prefetch" href="/blog/assets/js/19.a369c423.js"><link rel="prefetch" href="/blog/assets/js/20.fc252d8c.js"><link rel="prefetch" href="/blog/assets/js/3.835a6fd6.js"><link rel="prefetch" href="/blog/assets/js/4.c453bc54.js"><link rel="prefetch" href="/blog/assets/js/5.76fc70b2.js"><link rel="prefetch" href="/blog/assets/js/6.498ab014.js"><link rel="prefetch" href="/blog/assets/js/7.3822cadf.js"><link rel="prefetch" href="/blog/assets/js/8.53b6a155.js"><link rel="prefetch" href="/blog/assets/js/9.01deef7e.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.0b1ac558.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">前端</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/home/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/react/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/js/" class="nav-link">
  Js
</a></div><div class="nav-item"><a href="/blog/typescript/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/blog/webpack/" class="nav-link">
  Webpack
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/home/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/react/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/js/" class="nav-link">
  Js
</a></div><div class="nav-item"><a href="/blog/typescript/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/blog/webpack/" class="nav-link">
  Webpack
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/react/" aria-current="page" class="active sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/react/#函数组件与-class-组件" class="sidebar-link">函数组件与 class 组件</a></li><li class="sidebar-sub-header"><a href="/blog/react/#props" class="sidebar-link">Props</a></li><li class="sidebar-sub-header"><a href="/blog/react/#state" class="sidebar-link">State</a></li><li class="sidebar-sub-header"><a href="/blog/react/#区别" class="sidebar-link">区别</a></li><li class="sidebar-sub-header"><a href="/blog/react/#setstate栗子" class="sidebar-link">setState栗子</a></li><li class="sidebar-sub-header"><a href="/blog/react/#列表-key" class="sidebar-link">列表 &amp; Key</a></li><li class="sidebar-sub-header"><a href="/blog/react/#受控组件" class="sidebar-link">受控组件</a></li></ul></li><li><a href="/blog/react/React开发技巧.html" class="sidebar-link">React开发技巧</a></li><li><a href="/blog/react/ReactHooks.html" class="sidebar-link">React Hooks</a></li><li><a href="/blog/react/生命周期.html" class="sidebar-link">react 生命周期</a></li><li><a href="/blog/react/路由.html" class="sidebar-link">路由 React Router V5</a></li><li><a href="/blog/react/组件封装.html" class="sidebar-link">react组件封装</a></li><li><a href="/blog/react/Dva.html" class="sidebar-link">Dva</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react"><a href="#react" class="header-anchor">#</a> React</h1> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>React 是一个用于构建用户界面的 JavaScript 库</p></div> <h2 id="函数组件与-class-组件"><a href="#函数组件与-class-组件" class="header-anchor">#</a> 函数组件与 class 组件</h2> <h3 id="定义组件最简单的方式就是编写-javascript-函数"><a href="#定义组件最简单的方式就是编写-javascript-函数" class="header-anchor">#</a> 定义组件最简单的方式就是编写 JavaScript 函数</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Welcome</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数</p> <h3 id="使用-es6-的-class-来定义组件"><a href="#使用-es6-的-class-来定义组件" class="header-anchor">#</a> 使用 ES6 的 class 来定义组件</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Welcome</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>组件名称必须以大写字母开头
React 会将以小写字母开头的组件视为原生 DOM 标签。</p></div> <h3 id="将函数组件转换成-class-组件"><a href="#将函数组件转换成-class-组件" class="header-anchor">#</a> 将函数组件转换成 class 组件</h3> <p>创建一个同名的 ES6 class，并且继承于 React.Component。
添加一个空的 render() 方法。
将函数体移动到 render() 方法之中。
在 render() 方法中使用 this.props 替换 props。
删除剩余的空函数声明。</p> <h2 id="props"><a href="#props" class="header-anchor">#</a> Props</h2> <p>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改
组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props。
一般在组件之间传值用</p> <h2 id="state"><a href="#state" class="header-anchor">#</a> State</h2> <p>组件本身拥有的状态
不要直接修改 State(而是应该使用 setState()😃
构造函数是唯一可以给 this.state 赋值的地方</p> <h2 id="区别"><a href="#区别" class="header-anchor">#</a> 区别</h2> <p>props（“properties” 的缩写）和 state 都是普通的 JavaScript 对象。它们都是用来保存信息的，这些信息可以控制组件的渲染输出，而它们的一个重要的不同点就是：props 是传递给组件的（类似于函数的形参），而 state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。</p> <h3 id="state-的更新可能是异步的"><a href="#state-的更新可能是异步的" class="header-anchor">#</a> State 的更新可能是异步的</h3> <p>出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。</p> <p>因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p> <p>要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p> <h3 id="setstate到底是异步还是同步"><a href="#setstate到底是异步还是同步" class="header-anchor">#</a> setState到底是异步还是同步</h3> <p>setState只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的</p> <p>setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前,导致在合成事件和钩子函数中没法立⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果</p> <p>setState 的批量更新优化也是建立在“异步”(合成事件、钩子函数)之上的，在原生事件和setTimeout 中不会 批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一 次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</p> <h2 id="setstate栗子"><a href="#setstate栗子" class="header-anchor">#</a> setState栗子</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> formValues<span class="token operator">:</span> values <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>在callback中可以拿到更新后的值</p> <h2 id="列表-key"><a href="#列表-key" class="header-anchor">#</a> 列表 &amp; Key</h2> <p>key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识</p> <p>一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key</p> <p>当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key</p> <p>如果列表项目的顺序可能会变化，不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题</p> <p>key 只是在兄弟节点之间必须唯一</p> <h2 id="受控组件"><a href="#受控组件" class="header-anchor">#</a> 受控组件</h2> <p>在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同，这是因为表单元素通常会保持一些内部的 state</p> <p>表单具有默认的 HTML 表单行为，即在用户提交表单后浏览到新页面。如果你在 React 中执行相同的代码，它依然有效。但大多数情况下，使用 JavaScript 函数可以很方便的处理表单的提交， 同时还可以访问用户填写的表单数据。实现这种效果的标准方式是使用“受控组件”。</p> <p>表单元素（如input、 textarea 和 select）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/blog/react/React开发技巧.html">
        React开发技巧
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.b199bffd.js" defer></script><script src="/blog/assets/js/2.5239c051.js" defer></script><script src="/blog/assets/js/14.a6e55d05.js" defer></script>
  </body>
</html>
