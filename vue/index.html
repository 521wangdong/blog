<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue | 前端</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="王冬的个人博客">
    
    <link rel="preload" href="/blog/assets/css/0.styles.0b1ac558.css" as="style"><link rel="preload" href="/blog/assets/js/app.b199bffd.js" as="script"><link rel="preload" href="/blog/assets/js/2.5239c051.js" as="script"><link rel="preload" href="/blog/assets/js/19.a369c423.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.8711566b.js"><link rel="prefetch" href="/blog/assets/js/11.47db2a95.js"><link rel="prefetch" href="/blog/assets/js/12.97fcf21f.js"><link rel="prefetch" href="/blog/assets/js/13.185b2dd5.js"><link rel="prefetch" href="/blog/assets/js/14.a6e55d05.js"><link rel="prefetch" href="/blog/assets/js/15.7ade0bad.js"><link rel="prefetch" href="/blog/assets/js/16.ef875214.js"><link rel="prefetch" href="/blog/assets/js/17.2a263d49.js"><link rel="prefetch" href="/blog/assets/js/18.55103cda.js"><link rel="prefetch" href="/blog/assets/js/20.fc252d8c.js"><link rel="prefetch" href="/blog/assets/js/3.835a6fd6.js"><link rel="prefetch" href="/blog/assets/js/4.c453bc54.js"><link rel="prefetch" href="/blog/assets/js/5.76fc70b2.js"><link rel="prefetch" href="/blog/assets/js/6.498ab014.js"><link rel="prefetch" href="/blog/assets/js/7.3822cadf.js"><link rel="prefetch" href="/blog/assets/js/8.53b6a155.js"><link rel="prefetch" href="/blog/assets/js/9.01deef7e.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.0b1ac558.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">前端</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/home/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/blog/vue/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Vue
</a></div><div class="nav-item"><a href="/blog/js/" class="nav-link">
  Js
</a></div><div class="nav-item"><a href="/blog/typescript/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/blog/webpack/" class="nav-link">
  Webpack
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/home/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/blog/vue/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Vue
</a></div><div class="nav-item"><a href="/blog/js/" class="nav-link">
  Js
</a></div><div class="nav-item"><a href="/blog/typescript/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/blog/webpack/" class="nav-link">
  Webpack
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/vue/" aria-current="page" class="active sidebar-link">vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/vue/#生命周期" class="sidebar-link">生命周期</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#vue-组件中-data-必须是一个函数" class="sidebar-link">vue 组件中 data 必须是一个函数</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#v-if-和-v-show-有什么区别" class="sidebar-link">v-if 和 v-show 有什么区别</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#computed和watch的区别" class="sidebar-link">computed和watch的区别</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#nexttick" class="sidebar-link">$nextTick</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#v-for-key的作用" class="sidebar-link">v-for key的作用</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue"><a href="#vue" class="header-anchor">#</a> vue</h1> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <p>分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 和数据对象 data 都为 undefined，
还未初始化。在 created 阶段，vue 实例的数据对象 data 有了，el 为 undefined，还未初始化。</p></div> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom
节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。</p></div> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>当 data 变化时，会触发 beforeUpdate 和 updated 方法</p></div> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了
事件监听以及和 dom 的绑定，但是 dom 结构依然存在</p></div> <h2 id="vue-组件中-data-必须是一个函数"><a href="#vue-组件中-data-必须是一个函数" class="header-anchor">#</a> vue 组件中 data 必须是一个函数</h2> <div class="language-html extra-class"><pre class="language-html"><code>对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，
其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象
（Object的实例），引用地址不同，则不会出现这个问题
</code></pre></div><h2 id="v-if-和-v-show-有什么区别"><a href="#v-if-和-v-show-有什么区别" class="header-anchor">#</a> v-if 和 v-show 有什么区别</h2> <p>v-if 在条件切换时，会对标签进行适当的创建和销毁，而 v-show 则仅在初始化时加载一次，因此 v-if 的开销相对来说会比 v-show 大</p> <p>v-if 是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则 v-if 不会去渲染标签。v-show 则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的 CSS 切换</p> <h2 id="computed和watch的区别"><a href="#computed和watch的区别" class="header-anchor">#</a> computed和watch的区别</h2> <p>计算属性computed:</p> <p>支持缓存，只有依赖数据发生改变，才会重新进行计算
不支持异步，当computed内有异步操作时无效，无法监听数据的变化
computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值
如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed
如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p> <p>侦听属性watch:</p> <p>不支持缓存，数据变，直接会触发相应的操作
watch支持异步
监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值
当一个属性发生变化时，需要执行对应的操作；一对多
监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>immediate：组件加载立即触发回调函数执行</p></div> <div class="language-js extra-class"><pre class="language-js"><code>
watch<span class="token operator">:</span> <span class="token punctuation">{</span>
  firstName<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">handler</span><span class="token punctuation">(</span><span class="token parameter">newName<span class="token punctuation">,</span> oldName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>fullName <span class="token operator">=</span> newName <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 代表在wacth里声明了firstName这个方法之后立即执行handler方法</span>
    immediate<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler</p></div> <div class="language-js extra-class"><pre class="language-js"><code>watch<span class="token operator">:</span> <span class="token punctuation">{</span>
  obj<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">handler</span><span class="token punctuation">(</span><span class="token parameter">newName<span class="token punctuation">,</span> oldName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj.a changed'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    immediate<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    deep<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="nexttick"><a href="#nexttick" class="header-anchor">#</a> $nextTick</h2> <p>vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM</p></div> <h2 id="v-for-key的作用"><a href="#v-for-key的作用" class="header-anchor">#</a> v-for key的作用</h2> <div class="language-html extra-class"><pre class="language-html"><code>
key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大
限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会
移除 key 不存在的元素


有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。

当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。

为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性


</code></pre></div><div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item in items<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item.id<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>......<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.b199bffd.js" defer></script><script src="/blog/assets/js/2.5239c051.js" defer></script><script src="/blog/assets/js/19.a369c423.js" defer></script>
  </body>
</html>
